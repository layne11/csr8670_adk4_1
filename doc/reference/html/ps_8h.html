<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>BlueLab: ps.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BlueLab
   &#160;<span id="projectnumber">BlueLab-7.1-Release</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_885cc87fac2d91e269af0a5a959fa5f6.html">E:</a></li><li class="navelem"><a class="el" href="dir_c7e0e8d12b42f3739b71747656f18cd0.html">work_layne</a></li><li class="navelem"><a class="el" href="dir_21e8aa1b508721822d5da9358e8a66b3.html">layne</a></li><li class="navelem"><a class="el" href="dir_e4efa088505d514b69950f8abe76ce9a.html">csr8670</a></li><li class="navelem"><a class="el" href="dir_d69a05324820a15d5f908ec5057bc420.html">tools</a></li><li class="navelem"><a class="el" href="dir_33b4f9d0a7e332b5324a4fedfd59dca5.html">include</a></li><li class="navelem"><a class="el" href="dir_d66de6a51e5a24d2d6d7ec778992ab9f.html">firmware</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ps.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Access to persistent store.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae91e4ccb78bdb6cd48dd3393d3468887"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887">PsStores</a> { <br/>
&#160;&#160;<a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887aba40eeab25e66a9958662c4499f8159a">ps_store_default</a> = 0x0, 
<br/>
&#160;&#160;<a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887ab3b56d106ad40ad27ddbb58dbfc69020">ps_store_implementation</a> = 0x1, 
<br/>
&#160;&#160;<a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887a9663ca2f2fc70b9dddee0bcf40445e1a">ps_store_factory</a> = 0x2, 
<br/>
&#160;&#160;<a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887a2ff6207007475c4c3e8bf67cef6e5e0e">ps_store_rom</a> = 0x4, 
<br/>
&#160;&#160;<a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887a813617c052d3e4b4a99c2290ed62ffb2">ps_store_transient</a> = 0x8, 
<br/>
&#160;&#160;<a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887ae382a8b05a765a3cd97449161ee485ad">ps_store_application</a> = 0x10
<br/>
 }</td></tr>
<tr class="separator:ae91e4ccb78bdb6cd48dd3393d3468887"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a023228f45d2cede814c9bed9dcef5680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ps_8h.html#a023228f45d2cede814c9bed9dcef5680">PsStore</a> (<a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> key, const void *buff, <a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> words)</td></tr>
<tr class="memdesc:a023228f45d2cede814c9bed9dcef5680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the specified memory buffer to persistent store.  <a href="#a023228f45d2cede814c9bed9dcef5680">More...</a><br/></td></tr>
<tr class="separator:a023228f45d2cede814c9bed9dcef5680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e5381ab0482e665e9d7d4ff8760e74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ps_8h.html#a41e5381ab0482e665e9d7d4ff8760e74">PsRetrieve</a> (<a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> key, void *buff, <a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> words)</td></tr>
<tr class="memdesc:a41e5381ab0482e665e9d7d4ff8760e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to specified memory buffer from persistent store.  <a href="#a41e5381ab0482e665e9d7d4ff8760e74">More...</a><br/></td></tr>
<tr class="separator:a41e5381ab0482e665e9d7d4ff8760e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54108df504cb9ee3d4c90b5eb1cfea2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ps_8h.html#a54108df504cb9ee3d4c90b5eb1cfea2b">PsFlood</a> (void)</td></tr>
<tr class="memdesc:a54108df504cb9ee3d4c90b5eb1cfea2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flood fill the store to force a defragment at next boot.  <a href="#a54108df504cb9ee3d4c90b5eb1cfea2b">More...</a><br/></td></tr>
<tr class="separator:a54108df504cb9ee3d4c90b5eb1cfea2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790884c68662e0f25cce21d6aec19a46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ps_8h.html#a790884c68662e0f25cce21d6aec19a46">PsFreeCount</a> (<a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> len)</td></tr>
<tr class="memdesc:a790884c68662e0f25cce21d6aec19a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return how many keys of this size we could write.  <a href="#a790884c68662e0f25cce21d6aec19a46">More...</a><br/></td></tr>
<tr class="separator:a790884c68662e0f25cce21d6aec19a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24848f899c37a03f5ad510d66051faae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ps_8h.html#a24848f899c37a03f5ad510d66051faae">PsFullRetrieve</a> (<a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> key, void *buff, <a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> words)</td></tr>
<tr class="memdesc:a24848f899c37a03f5ad510d66051faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read any persistent store key which could be accessed from off-chip using BCCMD.  <a href="#a24848f899c37a03f5ad510d66051faae">More...</a><br/></td></tr>
<tr class="separator:a24848f899c37a03f5ad510d66051faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803dbd145cc26e0f966117973e79cf03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ps_8h.html#a803dbd145cc26e0f966117973e79cf03">PsStoreFsTab</a> (const void *buff, <a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> words, <a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> commit)</td></tr>
<tr class="memdesc:a803dbd145cc26e0f966117973e79cf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the specified memory buffer into PSKEY_FSTAB within the persistent store.  <a href="#a803dbd145cc26e0f966117973e79cf03">More...</a><br/></td></tr>
<tr class="separator:a803dbd145cc26e0f966117973e79cf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218eeae791e9c3b75eb200f825d3dad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ps_8h.html#a218eeae791e9c3b75eb200f825d3dad1">PsSetStore</a> (<a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887">PsStores</a> store)</td></tr>
<tr class="memdesc:a218eeae791e9c3b75eb200f825d3dad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PS Store that are used for subsequent PS operations.  <a href="#a218eeae791e9c3b75eb200f825d3dad1">More...</a><br/></td></tr>
<tr class="separator:a218eeae791e9c3b75eb200f825d3dad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1a86c9c80f7e8a46966ff4f3364afa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887">PsStores</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ps_8h.html#a8b1a86c9c80f7e8a46966ff4f3364afa">PsGetStore</a> (void)</td></tr>
<tr class="memdesc:a8b1a86c9c80f7e8a46966ff4f3364afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current PS store used for PS operations.  <a href="#a8b1a86c9c80f7e8a46966ff4f3364afa">More...</a><br/></td></tr>
<tr class="separator:a8b1a86c9c80f7e8a46966ff4f3364afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Access to persistent store. </p>
<p>A user application running on the VM can access the persistent store on BlueCore which provides a small amount of non-volatile storage.</p>
<p>Up to one hundred and fifty keys can be used, 0 to 149. There are no predefined meanings for these keys; they can be used for any purpose required by the user application. However, the total amount of data associated with all the keys should be kept as small as possible, at most 1024 words.</p>
<p>These keys are divided into three blocks of equal size and function</p>
<ul>
<li>User configuration data (0 to 49).</li>
<li>DSP configuration (50 to 99).</li>
<li>VM Connection Library data (100 to 149) NOTE: Applications MUST NOT use these.</li>
</ul>
<p>The first twenty-five in both blocks, 0 to 24 and 50 to 74, are protected against upload and modification via DFU (Device Firmware Upgrade) unless accompanied by a valid signature. Hence, they should be used for sensitive data such as cryptographic keys.</p>
<p>The maximum length of persistent store key that is guaranteed to be supported by the BlueCore firmware and its supporting tools is 64 words. Attempts to use longer persistent store keys may return failure or may cause undefined firmware behaviour.</p>
<dl class="section user"><dt>Notes</dt><dd>The persistent store is normally held in flash memory. This means that only a finite number of changes can be made to values held in persistent store without performing a defragment of the flash. The defragment is a time and memory intensive operation that is only performed at boot time. Hence the number of changes to the value of a key should be kept to a minimum. If the return code from <a class="el" href="ps_8h.html#a023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. ">PsStore()</a> indicates a failure then the chip needs to be reset for a defragment to occur. To control when defragmentation occurs, use <a class="el" href="ps_8h.html#a54108df504cb9ee3d4c90b5eb1cfea2b" title="Flood fill the store to force a defragment at next boot. ">PsFlood()</a> and <a class="el" href="boot_8h.html#a2ca590d41150774c4679511d07f1f7f0" title="Set the mode and force a reboot using a warm reset. ">BootSetMode()</a>. When persistent store is held in EEPROM, write operations to EEPROM are time consuming. So during Bluetooth activity, avoid back-to-back multiple PSKEY reads and writes since this may cause undefined firmware behaviour.</dd></dl>
<dl class="section user"><dt>Notes</dt><dd>Doing error checks on a key's value costs code space and usually has no effect. If the value of a key gives an error then it should be detected while the module is being designed (or by the tools if you have simple keys) and so the error checking is redundant in the field. The only exception is where it's possible to set a key in such a way that the chip doesn't boot. In this case, the user may be unable to recover the module once they've set the key. In this case, you may want to consider issuing a fault and falling back to sane values if the key is wrong. It may be worth considering overriding certain settings depending on other keys as a way of avoiding synchronised settings. If you end up overriding a whole key then the key is redundant and can be removed. If you override part of a key, say a bit fielded key, then it costs little code to simply apply a mask to the value read from persistent store and then set bits later. </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ae91e4ccb78bdb6cd48dd3393d3468887"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887">PsStores</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ae91e4ccb78bdb6cd48dd3393d3468887aba40eeab25e66a9958662c4499f8159a"></a>ps_store_default</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae91e4ccb78bdb6cd48dd3393d3468887ab3b56d106ad40ad27ddbb58dbfc69020"></a>ps_store_implementation</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae91e4ccb78bdb6cd48dd3393d3468887a9663ca2f2fc70b9dddee0bcf40445e1a"></a>ps_store_factory</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae91e4ccb78bdb6cd48dd3393d3468887a2ff6207007475c4c3e8bf67cef6e5e0e"></a>ps_store_rom</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae91e4ccb78bdb6cd48dd3393d3468887a813617c052d3e4b4a99c2290ed62ffb2"></a>ps_store_transient</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae91e4ccb78bdb6cd48dd3393d3468887ae382a8b05a765a3cd97449161ee485ad"></a>ps_store_application</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a023228f45d2cede814c9bed9dcef5680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> PsStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the specified memory buffer to persistent store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The persistent store key to copy data to. </td></tr>
    <tr><td class="paramname">buff</td><td>The memory buffer to copy data from. </td></tr>
    <tr><td class="paramname">words</td><td>The number of words to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of words actually written. Zero if either 'words' is zero or the store failed.</dd></dl>
<p>A Persistent store user key can be deleted by calling the PsStore function with <em>key</em> to be deleted and <em>words</em> argument being zero.</p>
<dl class="section note"><dt>Note</dt><dd>The key is interpreted as an index into PSKEY_USR0, ... PSKEY_USR49, PSKEY_DSP0 ... PSKEY_DSP49, PSKEY_USR50 ... PSKEY_USR99. No other keys can be written from an application.</dd>
<dd>
What <em>buff</em> can point to is currently restricted to regular RAM areas (globals, stack, and slots); a call to <a class="el" href="ps_8h.html#a023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. ">PsStore()</a> where <em>buff</em> points into the area returned by <a class="el" href="source_8h.html#a6d643b195dfdb398d0c0d2d8ab9d4ec5" title="Map the source into the address map, returning a pointer to the first byte in the source...">SourceMap()</a>, for example, will likely panic the application. This is not expected to be a common use of <a class="el" href="ps_8h.html#a023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. ">PsStore()</a>; in the unlikely event that it causes a problem, the application can indirect via a bounce buffer that's come from malloc() or the stack.</dd>
<dd>
If the VM application uses the VM software watchdog functionality, BlueCore firmware automatically extends the VM software watchdog before copying the memory buffer value to persistent store. This is only applicable if the PsStore type is EEPROM since EEPROM writes are time consuming. This ensures that the VM application is given enough time to kick the VM software watchdog once the PS write to EEPROM is completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a41e5381ab0482e665e9d7d4ff8760e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> PsRetrieve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy to specified memory buffer from persistent store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The persistent store key to copy data from. </td></tr>
    <tr><td class="paramname">buff</td><td>The memory buffer to copy data to. </td></tr>
    <tr><td class="paramname">words</td><td>The number of words to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>buff</em> is NULL and <em>words</em> is zero, returns the minimum length of the buffer necessary to hold the contents of <em>key</em>. Otherwise, returns the number of words actually read, or zero if the key does not exist or is longer than <em>words</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The key is interpreted as an index into PSKEY_USR0, ... PSKEY_USR49, PSKEY_DSP0 ... PSKEY_DSP49, PSKEY_USR50 ... PSKEY_USR99. No other keys can be written from an application. </dd></dl>

</div>
</div>
<a class="anchor" id="a54108df504cb9ee3d4c90b5eb1cfea2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PsFlood </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flood fill the store to force a defragment at next boot. </p>
<p>Subsequent attempts to write to persistent store will fail until then. </p>

</div>
</div>
<a class="anchor" id="a790884c68662e0f25cce21d6aec19a46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> PsFreeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>len</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return how many keys of this size we could write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The key size to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24848f899c37a03f5ad510d66051faae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> PsFullRetrieve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read any persistent store key which could be accessed from off-chip using BCCMD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The persistent store key to copy data from. </td></tr>
    <tr><td class="paramname">buff</td><td>The memory buffer to copy data to. </td></tr>
    <tr><td class="paramname">words</td><td>The number of words to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>buff</em> is NULL and <em>words</em> is zero, returns the minimum length of the buffer necessary to hold the contents of <em>key</em>. Otherwise, returns the number of words actually read, or zero if the key does not exist or is longer than <em>words</em>.</dd></dl>
<p>Note that this uses full CSR PS key numbering, not the 0..99 space used by the other Ps functions which are restricted to accessing the VM and DSP specific keys.</p>
<p>If a key is present (has a value) in any store (e.g., ROM, factory), stores layered on top of that (e.g., EEPROM, RAM) cannot cause the key to be absent. Therefore, making some behaviour conditional on the absence of a key is something to be avoided if at all possible. If the key has a default value in ROM, your behaviour will be impossible to access.</p>
<p>Note that you can override any value with a zero-length value, so testing for a zero-length value does not have this problem. Usually this means you can obey this rule by allowing a zero length key to behave the same as an absent key.</p>
<p>The correct way to read a key which may be a zero length pskey may will look like below uint16 pio = 0xffff; if (PsFullRetrieve(PSKEY_*., &amp;pio, sizeof(pio)) &amp;&amp; pio &lt;= 15) { enable feature using the PIO pin in pio } The initialisation of pio gives the value if the key isn't present, PsFullRetrieve returns FALSE if the key doesn't exist. </p>

</div>
</div>
<a class="anchor" id="a803dbd145cc26e0f966117973e79cf03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> PsStoreFsTab </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the specified memory buffer into PSKEY_FSTAB within the persistent store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>The memory buffer to copy data from. </td></tr>
    <tr><td class="paramname">words</td><td>The number of words to copy. </td></tr>
    <tr><td class="paramname">commit</td><td>Write the new FSTAB to non-volatile memory or not. If FALSE then the new FSTAB will only be stable across warm reboots; this feature can be used to enable the newly upgrade application to perform system checks before setting the FSTAB in the non-volatile store.</td></tr>
  </table>
  </dd>
</dl>
<p>The function operates in a similar manner to</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="ps_8h.html#a023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. ">PsStore</a> but only operates on the PSKEY_FSTAB persistent store key. The parameter commit is used to set which store the value will be written to. The data to write must always be passed to the function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation succeeded or FALSE if it failed </dd></dl>

</div>
</div>
<a class="anchor" id="a218eeae791e9c3b75eb200f825d3dad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PsSetStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887">PsStores</a>&#160;</td>
          <td class="paramname"><em>store</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the PS Store that are used for subsequent PS operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The PS store to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Any store in the BlueCore firmware can be set as default using this trap. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b1a86c9c80f7e8a46966ff4f3364afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ps_8h.html#ae91e4ccb78bdb6cd48dd3393d3468887">PsStores</a> PsGetStore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current PS store used for PS operations. </p>
<dl class="section return"><dt>Returns</dt><dd>The PS store currently used. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 2 2019 10:47:44 for BlueLab by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
