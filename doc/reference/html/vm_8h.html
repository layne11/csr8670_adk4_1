<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>BlueLab: vm.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BlueLab
   &#160;<span id="projectnumber">BlueLab-7.1-Release</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_885cc87fac2d91e269af0a5a959fa5f6.html">E:</a></li><li class="navelem"><a class="el" href="dir_c7e0e8d12b42f3739b71747656f18cd0.html">work_layne</a></li><li class="navelem"><a class="el" href="dir_21e8aa1b508721822d5da9358e8a66b3.html">layne</a></li><li class="navelem"><a class="el" href="dir_e4efa088505d514b69950f8abe76ce9a.html">csr8670</a></li><li class="navelem"><a class="el" href="dir_d69a05324820a15d5f908ec5057bc420.html">tools</a></li><li class="navelem"><a class="el" href="dir_33b4f9d0a7e332b5324a4fedfd59dca5.html">include</a></li><li class="navelem"><a class="el" href="dir_d66de6a51e5a24d2d6d7ec778992ab9f.html">firmware</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vm.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>VM access to low-level firmware and hardware.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab6174a6f6a49eaaf125ee06068a91d49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ab6174a6f6a49eaaf125ee06068a91d49">VmPutChar</a> (<a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> channel, <a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> c)</td></tr>
<tr class="memdesc:ab6174a6f6a49eaaf125ee06068a91d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a character on the given channel.  <a href="#ab6174a6f6a49eaaf125ee06068a91d49">More...</a><br/></td></tr>
<tr class="separator:ab6174a6f6a49eaaf125ee06068a91d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aaa28a27ec99b81a57cfda05500a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a02aaa28a27ec99b81a57cfda05500a72">VmGetAvailableAllocations</a> (void)</td></tr>
<tr class="memdesc:a02aaa28a27ec99b81a57cfda05500a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the maximum number of additional memory blocks which can be allocated.  <a href="#a02aaa28a27ec99b81a57cfda05500a72">More...</a><br/></td></tr>
<tr class="separator:a02aaa28a27ec99b81a57cfda05500a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03af15948e7d1e33957f054880b91878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a03af15948e7d1e33957f054880b91878">VmGetClock</a> (void)</td></tr>
<tr class="memdesc:a03af15948e7d1e33957f054880b91878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of a 32-bit millisecond timer.  <a href="#a03af15948e7d1e33957f054880b91878">More...</a><br/></td></tr>
<tr class="separator:a03af15948e7d1e33957f054880b91878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1785ecca01fc9ebeb000252198ca36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a9a1785ecca01fc9ebeb000252198ca36">VmDeepSleepEnable</a> (<a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> en)</td></tr>
<tr class="memdesc:a9a1785ecca01fc9ebeb000252198ca36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables deep sleep.  <a href="#a9a1785ecca01fc9ebeb000252198ca36">More...</a><br/></td></tr>
<tr class="separator:a9a1785ecca01fc9ebeb000252198ca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dfd59c130bc32c9ebd19d60f6f4e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ac7dfd59c130bc32c9ebd19d60f6f4e88">VmTransmitEnable</a> (<a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> enabled)</td></tr>
<tr class="memdesc:ac7dfd59c130bc32c9ebd19d60f6f4e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the radio transmitter be enabled or disabled.  <a href="#ac7dfd59c130bc32c9ebd19d60f6f4e88">More...</a><br/></td></tr>
<tr class="separator:ac7dfd59c130bc32c9ebd19d60f6f4e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa318c8d5fba4619c0029a91cc04af672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#aa318c8d5fba4619c0029a91cc04af672">VmTransmitPowerSetDefault</a> (<a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a> power)</td></tr>
<tr class="memdesc:aa318c8d5fba4619c0029a91cc04af672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the application to override the default specified by PSKEY_LC_DEFAULT_TX_POWER.  <a href="#aa318c8d5fba4619c0029a91cc04af672">More...</a><br/></td></tr>
<tr class="separator:aa318c8d5fba4619c0029a91cc04af672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af609631fa386bd0a2dcd0a182d7e0f37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#af609631fa386bd0a2dcd0a182d7e0f37">VmTransmitPowerSetMaximum</a> (<a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a> power)</td></tr>
<tr class="memdesc:af609631fa386bd0a2dcd0a182d7e0f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the application to override the maximum specified by PSKEY_LC_MAX_TX_POWER.  <a href="#af609631fa386bd0a2dcd0a182d7e0f37">More...</a><br/></td></tr>
<tr class="separator:af609631fa386bd0a2dcd0a182d7e0f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4606391ecb5d811f8abf0de8a8c7f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#abf4606391ecb5d811f8abf0de8a8c7f6">VmTransmitPowerGetDefault</a> (void)</td></tr>
<tr class="memdesc:abf4606391ecb5d811f8abf0de8a8c7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current default power setting.  <a href="#abf4606391ecb5d811f8abf0de8a8c7f6">More...</a><br/></td></tr>
<tr class="separator:abf4606391ecb5d811f8abf0de8a8c7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7466c263ec7f89013baf6dc81c8291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a8b7466c263ec7f89013baf6dc81c8291">VmTransmitPowerGetMaximum</a> (void)</td></tr>
<tr class="memdesc:a8b7466c263ec7f89013baf6dc81c8291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current maximum power setting.  <a href="#a8b7466c263ec7f89013baf6dc81c8291">More...</a><br/></td></tr>
<tr class="separator:a8b7466c263ec7f89013baf6dc81c8291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc7b1642cb8ff29eaafae10af122ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#addc7b1642cb8ff29eaafae10af122ee9">VmGetTemperature</a> (void)</td></tr>
<tr class="memdesc:addc7b1642cb8ff29eaafae10af122ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the internal temperature of BlueCore.  <a href="#addc7b1642cb8ff29eaafae10af122ee9">More...</a><br/></td></tr>
<tr class="separator:addc7b1642cb8ff29eaafae10af122ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed39856160114a494bda22e8c5ea782c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#aed39856160114a494bda22e8c5ea782c">VmSetPcmClock</a> (<a class="el" href="vm__if_8h.html#aa2f9a42547a4cef5951063a1959071c1">vm_pcm_clock_setting</a> frequency)</td></tr>
<tr class="memdesc:aed39856160114a494bda22e8c5ea782c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the VM to set the PCM_CLK frequency when using the 4 mHz internal clock.  <a href="#aed39856160114a494bda22e8c5ea782c">More...</a><br/></td></tr>
<tr class="separator:aed39856160114a494bda22e8c5ea782c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3dd147edcc2ea19d3ce2316ade376c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vm__if_8h.html#aa2f9a42547a4cef5951063a1959071c1">vm_pcm_clock_setting</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#aee3dd147edcc2ea19d3ce2316ade376c">VmGetPcmClock</a> (void)</td></tr>
<tr class="memdesc:aee3dd147edcc2ea19d3ce2316ade376c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the VM to check the current PCM_CLK frequency, when it is being generated from the 4MHz internal clock.  <a href="#aee3dd147edcc2ea19d3ce2316ade376c">More...</a><br/></td></tr>
<tr class="separator:aee3dd147edcc2ea19d3ce2316ade376c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c6c9873652447b7ababcc151a2bdc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ad8c6c9873652447b7ababcc151a2bdc0">VmAmuxClockEnable</a> (<a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> enabled)</td></tr>
<tr class="memdesc:ad8c6c9873652447b7ababcc151a2bdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the amux clock output on AIO0.  <a href="#ad8c6c9873652447b7ababcc151a2bdc0">More...</a><br/></td></tr>
<tr class="separator:ad8c6c9873652447b7ababcc151a2bdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d197784f84effbe11f38ceb3692a44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ae8d197784f84effbe11f38ceb3692a44">VmReadVrefConstant</a> (void)</td></tr>
<tr class="memdesc:ae8d197784f84effbe11f38ceb3692a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute value for Vref on this version of BlueCore.  <a href="#ae8d197784f84effbe11f38ceb3692a44">More...</a><br/></td></tr>
<tr class="separator:ae8d197784f84effbe11f38ceb3692a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1e8a83ba424fdb3b117c5fa6f13d21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a6a1e8a83ba424fdb3b117c5fa6f13d21">VmSendRfcommPrim</a> (void *prim)</td></tr>
<tr class="memdesc:a6a1e8a83ba424fdb3b117c5fa6f13d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an RFCOMM Bluestack primitive.  <a href="#a6a1e8a83ba424fdb3b117c5fa6f13d21">More...</a><br/></td></tr>
<tr class="separator:a6a1e8a83ba424fdb3b117c5fa6f13d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623628caf10541c84058d562a909b329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a623628caf10541c84058d562a909b329">VmSendL2capPrim</a> (void *prim)</td></tr>
<tr class="memdesc:a623628caf10541c84058d562a909b329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an L2CAP Bluestack primitive.  <a href="#a623628caf10541c84058d562a909b329">More...</a><br/></td></tr>
<tr class="separator:a623628caf10541c84058d562a909b329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7349b61ec91e3078739b24c9832f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a0c7349b61ec91e3078739b24c9832f64">VmSendDmPrim</a> (void *prim)</td></tr>
<tr class="memdesc:a0c7349b61ec91e3078739b24c9832f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a DM Bluestack primitive.  <a href="#a0c7349b61ec91e3078739b24c9832f64">More...</a><br/></td></tr>
<tr class="separator:a0c7349b61ec91e3078739b24c9832f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2a62ea647b44972a997650ffb74938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a1b2a62ea647b44972a997650ffb74938">VmSendSdpPrim</a> (void *prim)</td></tr>
<tr class="memdesc:a1b2a62ea647b44972a997650ffb74938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an SDP Bluestack primitive.  <a href="#a1b2a62ea647b44972a997650ffb74938">More...</a><br/></td></tr>
<tr class="separator:a1b2a62ea647b44972a997650ffb74938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29e1496922249cd04d17dd64558faab"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ac29e1496922249cd04d17dd64558faab">VmGetHandleFromPointer</a> (void *pointer)</td></tr>
<tr class="memdesc:ac29e1496922249cd04d17dd64558faab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a VM address space pointer to a handle.  <a href="#ac29e1496922249cd04d17dd64558faab">More...</a><br/></td></tr>
<tr class="separator:ac29e1496922249cd04d17dd64558faab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caccd8ae3cfa1246373caffe1d218b7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a5caccd8ae3cfa1246373caffe1d218b7">VmGetPointerFromHandle</a> (void *handle)</td></tr>
<tr class="memdesc:a5caccd8ae3cfa1246373caffe1d218b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a handle to a VM address space pointer.  <a href="#a5caccd8ae3cfa1246373caffe1d218b7">More...</a><br/></td></tr>
<tr class="separator:a5caccd8ae3cfa1246373caffe1d218b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accca4dbfa25d3d5529c0b8ab36773b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#accca4dbfa25d3d5529c0b8ab36773b92">VmGetTemperatureBySensor</a> (<a class="el" href="vm__if_8h.html#a843a397f7c3c7e9e8729bd1453576aa3">vm_temp_sensor</a> sensor)</td></tr>
<tr class="memdesc:accca4dbfa25d3d5529c0b8ab36773b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the temperature sensors on BlueCore BC7+ chips.  <a href="#accca4dbfa25d3d5529c0b8ab36773b92">More...</a><br/></td></tr>
<tr class="separator:accca4dbfa25d3d5529c0b8ab36773b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ce051e2f5da01808c83502a9a4f5f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ac7ce051e2f5da01808c83502a9a4f5f4">VmTransmitPowerMessagesEnable</a> (<a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> enable)</td></tr>
<tr class="memdesc:ac7ce051e2f5da01808c83502a9a4f5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows one <a class="el" href="system__message_8h.html#a9c0ef1009dee09f0eeee5f38a7d7e25b">MESSAGE_TX_POWER_CHANGE_EVENT</a> to be sent to the system task.  <a href="#ac7ce051e2f5da01808c83502a9a4f5f4">More...</a><br/></td></tr>
<tr class="separator:ac7ce051e2f5da01808c83502a9a4f5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0705e3271d59f90a2fe6f5437f37c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vm__if_8h.html#a20025e366d69691ea6cbb935504008e8">vm_reset_source</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ac0705e3271d59f90a2fe6f5437f37c6a">VmGetResetSource</a> (void)</td></tr>
<tr class="memdesc:ac0705e3271d59f90a2fe6f5437f37c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enum value relating to the cause of the last reset.  <a href="#ac0705e3271d59f90a2fe6f5437f37c6a">More...</a><br/></td></tr>
<tr class="separator:ac0705e3271d59f90a2fe6f5437f37c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8b7c36fb8b739b60e27db9bcce0429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#aff8b7c36fb8b739b60e27db9bcce0429">VmSendAttPrim</a> (void *prim)</td></tr>
<tr class="memdesc:aff8b7c36fb8b739b60e27db9bcce0429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an ATT Bluestack primitive.  <a href="#aff8b7c36fb8b739b60e27db9bcce0429">More...</a><br/></td></tr>
<tr class="separator:aff8b7c36fb8b739b60e27db9bcce0429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c4a776c5a7679f81f753db690c788a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a06c4a776c5a7679f81f753db690c788a">VmClearAdvertisingReportFilter</a> (void)</td></tr>
<tr class="memdesc:a06c4a776c5a7679f81f753db690c788a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the advertising filters, allowing all advert reports through to the host.  <a href="#a06c4a776c5a7679f81f753db690c788a">More...</a><br/></td></tr>
<tr class="separator:a06c4a776c5a7679f81f753db690c788a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77beb8d50391f79f5030a79a3d954f00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a77beb8d50391f79f5030a79a3d954f00">VmAddAdvertisingReportFilter</a> (<a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> operation, <a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> ad_type, <a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> interval, <a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> pattern_length, <a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> pattern_addr)</td></tr>
<tr class="memdesc:a77beb8d50391f79f5030a79a3d954f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helps in controlling how BlueCore filters advertising report events by BLE advertising data content.  <a href="#a77beb8d50391f79f5030a79a3d954f00">More...</a><br/></td></tr>
<tr class="separator:a77beb8d50391f79f5030a79a3d954f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48fb4c88a694e3a9a450705c03c64cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#ac48fb4c88a694e3a9a450705c03c64cd">VmGetPowerSource</a> (void)</td></tr>
<tr class="memdesc:ac48fb4c88a694e3a9a450705c03c64cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bit pattern representing the source of the voltage regulator enable signal on (re)boot.  <a href="#ac48fb4c88a694e3a9a450705c03c64cd">More...</a><br/></td></tr>
<tr class="separator:ac48fb4c88a694e3a9a450705c03c64cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e104a1dc884af12dbccd18a608018fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a6e104a1dc884af12dbccd18a608018fa">VmGetBdAddrtFromCid</a> (<a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> cid, <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *tpaddr)</td></tr>
<tr class="memdesc:a6e104a1dc884af12dbccd18a608018fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrives the <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> value from the given CID value.  <a href="#a6e104a1dc884af12dbccd18a608018fa">More...</a><br/></td></tr>
<tr class="separator:a6e104a1dc884af12dbccd18a608018fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269b447dc709fad74a31b0c794c9cf20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a269b447dc709fad74a31b0c794c9cf20">VmSoftwareWdKick</a> (<a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> timeout)</td></tr>
<tr class="memdesc:a269b447dc709fad74a31b0c794c9cf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, the VM software watchdog is disabled. Calling this trap with a valid timeout value will initiate/reset the VM software watchdog timer. If the VM software watchdog timer expires, then a VM Panic will be raised with Panic code VM_PANIC_SW_WD_EXPIRED and it will reset the BlueCore device.  <a href="#a269b447dc709fad74a31b0c794c9cf20">More...</a><br/></td></tr>
<tr class="separator:a269b447dc709fad74a31b0c794c9cf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1258d4e01d5cec00dd9a21ae73ed9966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vm_8h.html#a1258d4e01d5cec00dd9a21ae73ed9966">VmGetPublicAddress</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *random_addr, <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *public_addr)</td></tr>
<tr class="memdesc:a1258d4e01d5cec00dd9a21ae73ed9966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrives public address for a given random address.  <a href="#a1258d4e01d5cec00dd9a21ae73ed9966">More...</a><br/></td></tr>
<tr class="separator:a1258d4e01d5cec00dd9a21ae73ed9966"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>VM access to low-level firmware and hardware. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab6174a6f6a49eaaf125ee06068a91d49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmPutChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a character on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to output. </td></tr>
    <tr><td class="paramname">channel</td><td>The channel to output to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02aaa28a27ec99b81a57cfda05500a72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> VmGetAvailableAllocations </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the maximum number of additional memory blocks which can be allocated. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of free slots in the VM memory map. Note that this does not correspond to physical memory; it's possible for malloc() and similar functions to fail even when this function returns non-zero; the value returned by this function is only an upper bound on the number of possible allocations. See CS-110364-ANP "VM Memory Mapping and Memory Usage" for more detail. </dd></dl>

</div>
</div>
<a class="anchor" id="a03af15948e7d1e33957f054880b91878"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a4b435a49c74bb91f284f075e63416cb6">uint32</a> VmGetClock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current value of a 32-bit millisecond timer. </p>
<p>Don't poll this; using MessageSendLater is much more efficient. </p>

</div>
</div>
<a class="anchor" id="a9a1785ecca01fc9ebeb000252198ca36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> VmDeepSleepEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td>
          <td class="paramname"><em>en</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables deep sleep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">en</td><td>FALSE will prevent the chip going into deep sleep. TRUE will permit the chip to go into deep sleep. It can still be blocked from doing so by other firmware components, or by PSKEY_DEEP_SLEEP_STATE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous status. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7dfd59c130bc32c9ebd19d60f6f4e88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> VmTransmitEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td>
          <td class="paramname"><em>enabled</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request that the radio transmitter be enabled or disabled. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the request was satisfied, FALSE if it was not possible.</dd></dl>
<p>Equivalent to using ENABLE_TX and DISABLE_TX over BCCMD from off-chip. </p>

</div>
</div>
<a class="anchor" id="aa318c8d5fba4619c0029a91cc04af672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> VmTransmitPowerSetDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a>&#160;</td>
          <td class="paramname"><em>power</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the application to override the default specified by PSKEY_LC_DEFAULT_TX_POWER. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>int16 The new default power to use in dBm.</td></tr>
  </table>
  </dd>
</dl>
<p>The default transmit power is used for paging, inquiry, and their responses, and as the initial power for new acl links. The value passed is rounded down to the next available value when set, so the value returned by a call to VmTransmitPowerGetDefault may be less than that previously passed to VmTransmitPowerSetDefault.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, else FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="af609631fa386bd0a2dcd0a182d7e0f37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> VmTransmitPowerSetMaximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a>&#160;</td>
          <td class="paramname"><em>power</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the application to override the maximum specified by PSKEY_LC_MAX_TX_POWER. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>The new maximum power to use in dBm.</td></tr>
  </table>
  </dd>
</dl>
<p>The maximum transmit power is only referenced when increasing the transmit power, so if the transmit power on a link is already above this level the new value will not take effect until an attempt is made to increase the power.</p>
<p>The value passed is rounded down to the next available value when set, so the value returned by a call to VmTransmitPowerGetMaximum may be less than that previously passed to VmTransmitPowerSetMaximum.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, else FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="abf4606391ecb5d811f8abf0de8a8c7f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a> VmTransmitPowerGetDefault </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current default power setting. </p>

</div>
</div>
<a class="anchor" id="a8b7466c263ec7f89013baf6dc81c8291"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a> VmTransmitPowerGetMaximum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current maximum power setting. </p>

</div>
</div>
<a class="anchor" id="addc7b1642cb8ff29eaafae10af122ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a> VmGetTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the internal temperature of BlueCore. </p>
<dl class="section return"><dt>Returns</dt><dd>Approximate temperature in degrees Celsius, or INVALID_TEMPERATURE if it could not be read. </dd></dl>

</div>
</div>
<a class="anchor" id="aed39856160114a494bda22e8c5ea782c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> VmSetPcmClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vm__if_8h.html#aa2f9a42547a4cef5951063a1959071c1">vm_pcm_clock_setting</a>&#160;</td>
          <td class="paramname"><em>frequency</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the VM to set the PCM_CLK frequency when using the 4 mHz internal clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>The frequency PCM_CLK will output at as a vm_pcm_clock_setting type. Valid values are PCM_CLK_OFF, PCM_CLK_128, PCM_CLK_256 and PCM_CLK_512 kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the change was accepted, else FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="aee3dd147edcc2ea19d3ce2316ade376c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vm__if_8h.html#aa2f9a42547a4cef5951063a1959071c1">vm_pcm_clock_setting</a> VmGetPcmClock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the VM to check the current PCM_CLK frequency, when it is being generated from the 4MHz internal clock. </p>
<dl class="section return"><dt>Returns</dt><dd>A vm_pcm_clock_setting type indicating the current PCM clock frequency. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8c6c9873652447b7ababcc151a2bdc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmAmuxClockEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td>
          <td class="paramname"><em>enabled</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the amux clock output on AIO0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Whether the clock is enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this is only available on BC4 parts, excluding BC4-external.</p>
<p>Note that PSKEY_AMUX_CLOCK must be have been set correctly, and PSKEY_AMUX_AIO0 must be set to ANA_AMUX_A_SEL_DIG_OUT_CLK_AMUX. </p>

</div>
</div>
<a class="anchor" id="ae8d197784f84effbe11f38ceb3692a44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> VmReadVrefConstant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the absolute value for Vref on this version of BlueCore. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of Vref (in mV) for the version of BlueCore the application is running on.</dd></dl>
<p>This is a constant value for a given version of BlueCore. See <a class="el" href="adc_8h.html" title="Access to ADC hardware. ">adc.h</a> for the intended use of this function.</p>
<p>In version 23 and prior firmware, <a class="el" href="adc_8h.html#a886a006bb397a4940e1d4d181ab86991" title="Send a request to the ADC to make a reading from adc_source. When the reading is made, a MESSAGE_ADC_RESULT message will be sent to the task passed. See adc.h for how to interpret the result. ">AdcRequest()</a> would return a reading for Vref scaled as if its nominal value were 1250mV, and (for instance) the battery library could assume this.</p>
<p>From version 25 firmware onwards, <a class="el" href="adc_8h.html#a886a006bb397a4940e1d4d181ab86991" title="Send a request to the ADC to make a reading from adc_source. When the reading is made, a MESSAGE_ADC_RESULT message will be sent to the task passed. See adc.h for how to interpret the result. ">AdcRequest()</a> will return a reading for Vref (<a class="el" href="adc__if_8h.html#a4d75ac13b1929d4d7c6c60b1666a1e1ea34b6f469ad07095bfaeaaafe8b9c1283">adcsel_vref</a>) without scaling it to a nominal voltage. This function provides the information that the battery library needs to adjust its readings appropriately. </p>

</div>
</div>
<a class="anchor" id="a6a1e8a83ba424fdb3b117c5fa6f13d21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendRfcommPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an RFCOMM Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a623628caf10541c84058d562a909b329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendL2capPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an L2CAP Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c7349b61ec91e3078739b24c9832f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendDmPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a DM Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b2a62ea647b44972a997650ffb74938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendSdpPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an SDP Bluestack primitive. </p>

</div>
</div>
<a class="anchor" id="ac29e1496922249cd04d17dd64558faab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VmGetHandleFromPointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a VM address space pointer to a handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>The pointer to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>When assembling a primitive which includes indirect blocks, the application must:</p>
<ul>
<li>Allocate a block</li>
<li>Convert it to a handle</li>
<li>Store the handle in the primitive rather than storing the pointer itself </li>
</ul>

</div>
</div>
<a class="anchor" id="a5caccd8ae3cfa1246373caffe1d218b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VmGetPointerFromHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a handle to a VM address space pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>If a Bluestack primitive refers to indirect blocks of memory, those are presented in the primitive as handles rather than real pointers. To access the data an application must pass the handle to <a class="el" href="vm_8h.html#a5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. ">VmGetPointerFromHandle()</a> which will make the indirect block visible to the application. The application must call this exactly once for each such indirect block, and the resulting pointers must all be passed to free. Failure to perform this procedure will result in a resource leak. Note - while <a class="el" href="vm_8h.html#ac29e1496922249cd04d17dd64558faab" title="Converts a VM address space pointer to a handle. ">VmGetHandleFromPointer()</a> will successfully produce a handle from a pointer to a constant, <a class="el" href="vm_8h.html#a5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. ">VmGetPointerFromHandle()</a> will not produce a pointer from such a handle. It will instead panic with VM_PANIC_READ_FROM_ILLEGAL_ADDRESS. </p>

</div>
</div>
<a class="anchor" id="accca4dbfa25d3d5529c0b8ab36773b92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a4355d16fcf9f644c9ac84293f0b1801f">int16</a> VmGetTemperatureBySensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vm__if_8h.html#a843a397f7c3c7e9e8729bd1453576aa3">vm_temp_sensor</a>&#160;</td>
          <td class="paramname"><em>sensor</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the temperature sensors on BlueCore BC7+ chips. </p>
<dl class="section return"><dt>Returns</dt><dd>Temperature in degrees Celsius, or INVALID_TEMPERATURE if it could not be read.</dd></dl>
<p>Sensor Action TSENSOR_MAIN Reads cached temp from main sensor TSENSOR_PMU Reads temp from PMU sensor xxx All other sensor numbers return INVALID_SENSOR </p>

</div>
</div>
<a class="anchor" id="ac7ce051e2f5da01808c83502a9a4f5f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmTransmitPowerMessagesEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a>&#160;</td>
          <td class="paramname"><em>enable</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows one <a class="el" href="system__message_8h.html#a9c0ef1009dee09f0eeee5f38a7d7e25b">MESSAGE_TX_POWER_CHANGE_EVENT</a> to be sent to the system task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>TRUE to permit power change messages to be sent, FALSE to stop them.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a one-shot enable, i.e., it allows exactly one power change message to be sent to the task registered with <a class="el" href="message_8h.html#abd1023998e25adee54f220a8d71736ae" title="Register a task to handle system-wide messages. ">MessageSystemTask()</a>. Once that message has been sent, <a class="el" href="vm_8h.html#ac7ce051e2f5da01808c83502a9a4f5f4" title="Allows one MESSAGE_TX_POWER_CHANGE_EVENT to be sent to the system task. ">VmTransmitPowerMessagesEnable()</a> must be called again to allow the next power change message to be sent. This gives the application the opportunity to limit the rate at which power change messages arrive, which can be quite frequent if unchecked.</p>
<p>Calling VmTransmitPowerMessagesEnable(TRUE) again before a power change message has been received has no effect. </p>

</div>
</div>
<a class="anchor" id="ac0705e3271d59f90a2fe6f5437f37c6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vm__if_8h.html#a20025e366d69691ea6cbb935504008e8">vm_reset_source</a> VmGetResetSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an enum value relating to the cause of the last reset. </p>
<pre class="fragment">   When a system reset occurs on BC7 chips a value is stored which 
   relates to the cause of the reset.  This value can be retrieved by a 
   VM app and takes the enumerated values defined in the #vm_reset_source 
   type. Any value not covered by this definition cannot be determined 
   and is deemed an unexpected reset.

   See the type definition for more information.
</pre><dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="vm__if_8h.html#a20025e366d69691ea6cbb935504008e8" title="Enumerated type indicating reset source. This is the return type of VmGetResetSource(). ">vm_reset_source</a> type indicating the source of the last reset. </dd></dl>

</div>
</div>
<a class="anchor" id="aff8b7c36fb8b739b60e27db9bcce0429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendAttPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an ATT Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06c4a776c5a7679f81f753db690c788a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> VmClearAdvertisingReportFilter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the advertising filters, allowing all advert reports through to the host. </p>

</div>
</div>
<a class="anchor" id="a77beb8d50391f79f5030a79a3d954f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> VmAddAdvertisingReportFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>ad_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>pattern_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>pattern_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This helps in controlling how BlueCore filters advertising report events by BLE advertising data content. </p>
<pre class="fragment">   Filtering is based only on the contents of advertising
   data. Since directed connectable adverts do not contain advertising
   data, and they are expressly intended for the receiving device,
   they are always passed to the host and are unaffected by this
   filter. The event type, Bluetooth device address of the sender and 
   other properties of the advertising reports are ignored by the 
   filter.

   With no filter present, all advertising packets received during 
   scanning are passed to the host in LE Advertising Report Events, 
   subject to advert flood protection. The filter is used to select 
   advertising reports based on the contents of the advertising data
   (AD) and send to the host only the matching reports, thus saving
   the host being woken up unnecessarily.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>Describes the relationship between multiple filters. Currently the only valid operation is OR (0x00), meaning that adverts will be sent to the host if they are matched by any of the filters.</td></tr>
    <tr><td class="paramname">ad_type</td><td>The AD type of the AD structure to match. The filter will only match adverts containing an AD structure of this type. Enum as defined in Bluetooth Assigned Numbers.</td></tr>
    <tr><td class="paramname">interval</td><td>The interval for repeated attempts to match the pattern in the data portion of the AD structure. For example, if the interval is 4 then we attempt to match at offsets, 0, 4, 8, 12, etc in the data portion of the AD structure. If interval is 0 then we only attempt to match at offset 0. If interval is 0xffff, then exact match is required.</td></tr>
    <tr><td class="paramname">pattern_length</td><td>The length of the pattern data, i.e. number of uint8s pattern data present in location pointed by <em>pattern_addr</em>.</td></tr>
    <tr><td class="paramname">pattern_addr</td><td>A pointer to the location where pattern data is present. Each pattern data is 8bit data and no two pattern data should be packed inside uint16. BlueCore will only consider lower 8 bit of each pattern data for pattern matching. If pattern_addr is NULL, then no pattern matching. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac48fb4c88a694e3a9a450705c03c64cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> VmGetPowerSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a bit pattern representing the source of the voltage regulator enable signal on (re)boot. </p>
<pre class="fragment">   When the voltage regulators of a CSR8670 or CSR8670-like chip are 
   enabled as part of the turn-on sequence or during reset, a value is 
   stored indicating the source of the signals responsible for enabling 
   the chip's power supplies.  This value can be retrieved by a VM app and 
   is a bit-pattern composed of the enumerated values defined in the 
   #vm_power_enabler type.

   See the type definition for more information.
</pre><dl class="section return"><dt>Returns</dt><dd>A bit pattern representing regulator enabling signals. See the <a class="el" href="vm__if_8h.html#aff56fe8b1c178789145309e37bc4bd7b" title="Bit masks representing the source of the voltage regulator enable signal on (re)boot. This type is used by VmGetPowerSource() to construct the bit-pattern which is its return value. ">vm_power_enabler</a> type definition. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e104a1dc884af12dbccd18a608018fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> VmGetBdAddrtFromCid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>tpaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrives the <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> value from the given CID value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>The connection identifier to fetch the Bluetooth address from. </td></tr>
    <tr><td class="paramname">tpaddr</td><td>If the address is found it will be returned to the location pointed at by this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if an address was found for a given CID, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a269b447dc709fad74a31b0c794c9cf20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> VmSoftwareWdKick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>timeout</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, the VM software watchdog is disabled. Calling this trap with a valid timeout value will initiate/reset the VM software watchdog timer. If the VM software watchdog timer expires, then a VM Panic will be raised with Panic code VM_PANIC_SW_WD_EXPIRED and it will reset the BlueCore device. </p>
<p>Whenever the VM software watchdog timer expires with the debugger attached, BlueCore firmware will never panic/reset the chip since it is unpredictable to calculate the time to extend the VM software watchdog timer due to the delay caused during debugging.</p>
<p>Firmware will automatically extend the VM software watchdog timer during long firmware operations such as Serial flash erase, PSKey write on EEPROM device, so that the VM software watchdog timer is not unduly affected.</p>
<p>For other operations at host which may take some time to complete, the BlueCore firmware does not automatically extend the VM software watchdog timer because the time taken is dependent on the individual scenario with the Host. It is left to the application to extend/kick the VM software watchdog timer. As the UART Host operations are much slower than USB, it is suggested that longer VM software watchdog timeout values are used with UART Host operations. Typically, VM application is not blocked during the Host communication. During the Host communication, there is sufficient time left in the BlueCore firmware to schedule the VM application and thus, VM application can kick the VM software watchdog timer.</p>
<p>The time taken to start the DSP application depends on the details of the DSP application, which can not be predicted by the BlueCore firmware. If the VM software watchdog is in use, the VM application should consider the time taken to start the DSP application when deciding on the timeout value. The BlueCore firmware will not automatically extend the timeout.</p>
<p>The VM software watchdog is used to detect the misbehaving applications that have gone off the rails. If the BlueCore firmware disables VM software watchdog by calling the trap <a class="el" href="vm_8h.html#a269b447dc709fad74a31b0c794c9cf20" title="By default, the VM software watchdog is disabled. Calling this trap with a valid timeout value will i...">VmSoftwareWdKick()</a> with single disable code zero, then it is possible for a rogue application to get there with AL set to zero (quite a common value to have in AL)which will disable the watchdog and prevent the system recovering. To avoid this unintended behaviour and to be confident that firmware code will not disable the VM software watchdog even if VM application branches inappropriately, a 3-stage disable sequence is required.</p>
<p>The 3-stage disable sequence to disable the VM software watchdog is as follows: VmSoftwareWdKick(VM_SW_WATCHDOG_DISABLE_CODE1) VmSoftwareWdKick(VM_SW_WATCHDOG_DISABLE_CODE2) VmSoftwareWdKick(VM_SW_WATCHDOG_DISABLE_CODE3)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout period in seconds, in the range 1 to 300 or the specific disable codes VM_SW_WATCHDOG_DISABLE_CODE1, VM_SW_WATCHDOG_DISABLE_CODE2, VM_SW_WATCHDOG_DISABLE_CODE3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns TRUE, 1.Whenever the VM software watchdog is kicked i.e., valid range (1-300 seconds). Eg: VmsoftwareWDKick(20); - Returns TRUE 2.Whenever the 3-stage disable sequence is followed as per the requirement. Eg: VmsoftwareWDKick(20); - Returns TRUE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE1); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE2); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE3); - Returns TRUE</dd></dl>
<p>returns FALSE, 1.Whenever the VM software watchdog timeout doesn't fall under 1-300 seconds range. 2.Whenever the VM software watchdog doesn't follow the 3-stage sequence or disabling the VM software watchdog fails. Eg: VmsoftwareWDKick(20); - Returns TRUE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE2); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE1); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE3); - Returns FALSE</p>
<dl class="section note"><dt>Note</dt><dd>The purpose of the 3-stage disable sequence is to ensure that rogue applications do not randomly disable the watchdog by kicking it with some single disable codes. The return value of the this trap is designed to indicate to the user that either the watchdog kick has succeeded due to a valid timeout within the specified range or that the entire 3-stage disable sequence has succeeded. Returning TRUE for a call on the first disable sequence alone would actually go against the notion that the operation of disabling the watchdog has succeeded. In-fact at that moment (after having kicked with the first disable code), there is no guarantee of whether the disabling is either being done deliberately (in a valid manner) or the kick has been called by some rouge code. Hence, unless the entire disable operation does not succeed, the VM must not return TRUE. </dd></dl>

</div>
</div>
<a class="anchor" id="a1258d4e01d5cec00dd9a21ae73ed9966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csrtypes_8h.html#a5341710c15e14e51d946a5a5f14b27a6">bool</a> VmGetPublicAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>random_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>public_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrives public address for a given random address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">random_addr</td><td>Random address. </td></tr>
    <tr><td class="paramname">public_addr</td><td>If the public address is found it will be returned to the location pointed at by this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if public address was found for a given resolvable random address, FALSE otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 2 2019 10:47:44 for BlueLab by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
