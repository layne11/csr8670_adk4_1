<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>BlueLab: Host communication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BlueLab
   &#160;<span id="projectnumber">BlueLab-7.1-Release</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Host communication </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="host_messages"></a>
16-bit data in messages</h1>
<h2><a class="anchor" id="host_message_fmt"></a>
Format of a packet</h2>
<p>The packet format that is used by the VM for communications is very simple, but allows the user to implement a large number of features on top of the simple interface that we provide. The packet begins with one 16-bit word indicating the length of the packet (including the header), followed by a sub-type word. For messages the sub-type can have any value in the range of 0-127 (0x00-0x7f), and is meant to indicate the type of the packet to the code at either end. There are no restrictions on the use of this word, as long as it is within the correct range. The remaining words in the packet can contain any 16-bit data.</p>
<p>Typically the sub-type field is used to multiplex an number of distinct channels between the application and the host.</p>
<p>All packets are held in dynamic memory blocks and the constraints on number and size of these described in the standard library apply to packets.</p>
<table class="doxtable">
<tr>
<td>Length (16bit) </td><td>Sub-type (16bit) </td><td>Data...  </td></tr>
</table>
<p>To receive packets from the host, the application must register a task for <a class="el" href="system__message_8h.html#ac3bb1b330d705149f9c84df24dd00768">MESSAGE_FROM_HOST</a> using <a class="el" href="message_8h.html#a96fee19a89278d84a3c5df047191b754" title="Register a task to handle HostComms primitives. ">MessageHostCommsTask()</a>.</p>
<h2><a class="anchor" id="host_message_code"></a>
Example code</h2>
<p>Send a small packet to the host </p>
<div class="fragment"><div class="line"><a class="code" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *data = <a class="code" href="panic_8h.html#ac2cbbcab5783657bfe528a818be2eaa4" title="Allocates sz words and returns a pointer to the memory if successful. If the memory allocation fails...">PanicUnlessMalloc</a>(3 * <span class="keyword">sizeof</span>(<a class="code" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>));</div>
<div class="line">data[0] = 3; <span class="comment">// length</span></div>
<div class="line">data[1] = 0x7e; <span class="comment">// sub-type</span></div>
<div class="line">data[2] = 0x1234; <span class="comment">// data</span></div>
<div class="line"><a class="code" href="host_8h.html#afc4867fe809327a464eca3c9851f0193" title="Send a message to the host on BCSP:13. ">HostSendMessage</a>(data);</div>
<div class="line">data = NULL; <span class="comment">// we don&#39;t own this block anymore</span></div>
</div><!-- fragment --><h1><a class="anchor" id="host_streams"></a>
8-bit data over Streams</h1>
<p>There are 256 sources and 256 sinks associated with stream-based host communications; an application might use one for control and one for data.</p>
<p>An application can obtain the source and sink for a particular one of the 256 channels using the <a class="el" href="stream_8h.html#a0d222770974b2dcd2de4f4b32e38205f" title="Get the Source for the specified stream-based BCSP#13 channel. ">StreamHostSource()</a> and <a class="el" href="stream_8h.html#affd32c6bb78997f1f36ccaf32d42d1bf" title="Get the Sink for the specified stream-based BCSP#13 channel. ">StreamHostSink()</a> functions. The source and sink are then manipulated using the other functions from the <a class="el" href="stream_8h.html" title="Sources and sinks of 8-bit data. ">stream.h</a> library.</p>
<h2><a class="anchor" id="host_stream_fmt"></a>
Format of a packet</h2>
<p>The format of a packet is almost identical to that used for messages; this preserves compatibility with existing firmware, at the cost of making the stream-based protocol more complex than strictly necessary.</p>
<p>The packet again begins with one 16-bit word indicating the length of the packet in words (including the header), followed by a sub-type word. The payload follows, with the bytes packed into 16-bit words in low-byte high-byte order and padded out to a 16-bit boundary. That is a payload of 0x01, 0x02, 0x03 will be packed as 0x0201, 0x0003. For streams the sub-type can have any value in the range of 0x100-0x2ff, and encodes both the stream being used and whether the payload includes a padding byte.</p>
<p>The bottom 8-bits of the sub-type word encode the channel for the source or sink. If the top 8-bits are 2 then all of the bytes of the payload are used, if 1 then the top byte of the last word is not part of the payload.</p>
<p>In other words, a consumer might look like: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> incoming(<span class="keyword">const</span> <a class="code" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *packet)</div>
<div class="line">{</div>
<div class="line"><a class="code" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> words = packet[0];</div>
<div class="line"><a class="code" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> type  = packet[1];</div>
<div class="line"><a class="code" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> chan  = type &amp; 0xff;</div>
<div class="line"><a class="code" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> bytes = (words - 2) * 2 - ((type &gt;&gt; 8) == 1);</div>
<div class="line">...</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="host_stream_code"></a>
Example code</h2>
<p>Send a 2 byte packet to the host on channel 1 </p>
<div class="fragment"><div class="line"><a class="code" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink = <a class="code" href="panic_8h.html#a5f213a19d903e302c9772792603d7874" title="Panics the application if the pointer passed is NULL, otherwise returns the pointer. ">PanicNull</a>(<a class="code" href="stream_8h.html#affd32c6bb78997f1f36ccaf32d42d1bf" title="Get the Sink for the specified stream-based BCSP#13 channel. ">StreamHostSink</a>(1));</div>
<div class="line"><a class="code" href="csrtypes_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> *data = <a class="code" href="sink_8h.html#a90fa999d02ab67d94ff39f657b979a64" title="Map the sink into the address map, returning a pointer to the first byte in the sink. ">SinkMap</a>(sink) + <a class="code" href="sink_8h.html#ad33984eda4f93d6b4b3402ddf9ada719" title="Attempt to claim the indicated number of extra bytes in a sink. ">SinkClaim</a>(sink, 2);</div>
<div class="line">data[0] = 0x12;</div>
<div class="line">data[1] = 0x34;</div>
<div class="line"><a class="code" href="panic_8h.html#a7988c29a17ab6d1bfbbe476ae481e7d5">PanicZero</a>(<a class="code" href="sink_8h.html#a4fcdc75c8a60b0d2edb1e0bf92994a03" title="Flush the indicated number of bytes out of the sink. ">SinkFlush</a>(sink, 2));</div>
</div><!-- fragment --><p>Process packets from the host on channel 2 </p>
<div class="fragment"><div class="line"><a class="code" href="csrtypes_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> size;</div>
<div class="line"><a class="code" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source = <a class="code" href="stream_8h.html#a0d222770974b2dcd2de4f4b32e38205f" title="Get the Source for the specified stream-based BCSP#13 channel. ">StreamHostSource</a>(2);</div>
<div class="line"><span class="keywordflow">while</span> ((size = <a class="code" href="source_8h.html#af671f63da2440f82542e8444cdfb199e" title="Return how many bytes in this source are before the next packet boundary (for non packet-based source...">SourceBoundary</a>(source)) != 0)</div>
<div class="line">{</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="csrtypes_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> *data = <a class="code" href="source_8h.html#a6d643b195dfdb398d0c0d2d8ab9d4ec5" title="Map the source into the address map, returning a pointer to the first byte in the source...">SourceMap</a>(source);</div>
<div class="line"><span class="comment">// do something with the data here</span></div>
<div class="line"><a class="code" href="source_8h.html#ae56caaf5efeee75f7d7f0cd49f2b7f4f" title="Discards the indicated number of bytes from the front of the source. ">SourceDrop</a>(source, size);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="host_issues"></a>
Related Issues</h1>
<h2><a class="anchor" id="host_limitations"></a>
Limitations</h2>
<p>All packets must fit in an available on-chip memory block and as such are restricted to around 80 words in total. This restriction applies even to stream-based messages.</p>
<p>If a packet arrives for a source and insufficient space is available, the message will be silently discarded. Users can expect to have at most 200 bytes of data held in any source associated with host communications.</p>
<h2><a class="anchor" id="host_coex"></a>
Coexistence</h2>
<p>Both message and stream based host communications can be used in the same application as required; the second word of a data message is used to distinguish between the two formats.</p>
<p>Which is more appropriate depends on your application: streams are designed for 8-bit data, while messages are more suited to packed binary data such as structures.</p>
<h2><a class="anchor" id="host_h4"></a>
H4 and USB compatibility</h2>
<p>It is possible to use the HOST library functions over both H4 and USB. In this case, packets will be tunneled over HCI using the manufacturers' extension command as documented in HCI Extensions bcore-sp-009P.</p>
<h2><a class="anchor" id="host_ps"></a>
Persistent store</h2>
<p>It is possible (but unlikely) that BCSP channel 13 is not enabled. If the HOST functions don't seem to be working, check that BCSP channel 13 is enabled in the persistent store.</p>
<p>To do this run PSTool and check PSKEY_HOSTIO_PROTOCOL_INFO13 to make sure that the value of the key is "0x0100 0xb800". </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 2 2019 10:47:44 for BlueLab by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
