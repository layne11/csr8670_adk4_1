// *****************************************************************************
// Copyright (c) 2005 - 2015 Qualcomm Technologies International, Ltd.
// Part of ADK 4.1
//
// *****************************************************************************
#ifndef SRA_GAMING_HEADER
#define SRA_GAMING_HEADER


#ifdef FASTSTREAM_ENABLE
.CONST $sra.NO_ACTIVITY_PERIOD             30;  //the port is regarded inactive if no activity seen for this minumum number of interrupt
#else
.CONST $sra.NO_ACTIVITY_PERIOD             50;  //the port is regarded inactive if no activity seen for this minumum number of interrupt
#endif
.CONST $sra.ACTIVITY_PERIOD_BEFORE_START   100; //SRA counting starts if port has bee active during past ACTIVITY_PERIOD_BEFORE_START interrupts

 // mode definition for sra thread (runs in interrupt)
.CONST $sra.IDLE_MODE                      0;   // SRA in idle mode is wating for the port to becomes active, usually doesnt stay in idle mode
.CONST $sra.COUNTING_MODE                  1;   // in counting mode it just waits to reach the end of counting period (20 seconds), goes to idle then

 // mode definitions for rate_calc thread (runs in background)
.CONST $sra.RATECALC_IDLE_MODE             0;   // waits for sra thread to tag the start
.CONST $sra.RATECALC_START_MODE            1;   // waits until the codec passes the start tag
.CONST $sra.RATECALC_ADD_MODE              2;   // count the total number of PCM samples generated by CODEC since start time

.CONST $sra.TRANSIENT_SAVING_MODE          0;   // history has not get full yet
.CONST $sra.STEADY_SAVING_MODE             1;   // history is now full


.CONST $sra.BUFF_SIZE 32;                        // history buffer size, must be a power of 2

 // sra structure fields, except for input fields, leave all initialized to zero
.CONST $sra.TAG_DURATION_FIELD                      0;  //input: duration of the rate calc (in number of interrupts)
.CONST $sra.CODEC_PORT_FIELD                        1;  //input: codec input port to check activity
.CONST $sra.CODEC_CBUFFER_TO_TAG_FIELD              2;  //input: codec input cbuffer to tag the times
.CONST $sra.AUDIO_CBUFFER_TO_TAG_FIELD              3;  //input: audio output cbuffer to count PCM samples
.CONST $sra.MAX_RATE_FIELD                          4;  //input: maximum possible rate
.CONST $sra.AUDIO_AMOUNT_EXPECTED_FIELD             5;  //input: amount of PCM sample expected to receive in one period (FS*TAG_DURATION_FIELD*interrupt_time)
.CONST $sra.TARGET_LEVEL_FIELD                      6;  //input: target buffer level (expressed as a fractional value)
.CONST $sra.CODEC_DATA_READ_FIELD                   7;  //internal state, previous read address
.CONST $sra.NO_CODEC_DATA_COUNTER_FIELD             8;  //internal state, counter to keep no activity period
.CONST $sra.ACTIVE_PERIOD_COUNTER_FIELD             9;  //internal state, counter to store active period
.CONST $sra.MODE_FIELD                              10; //internal state, sra thread mode
.CONST $sra.CODEC_CBUFFER_START_ADDR_TAG_FIELD      11; //internal state, start tag
.CONST $sra.CODEC_CBUFFER_END_ADDR_TAG_FIELD        12; //internal state, end tag
.CONST $sra.TAG_TIME_COUNTER_FIELD                  13; //internal state, tag time counter
.CONST $sra.RATECALC_MODE_FIELD                     14; //internal state, rate_calc thread mode
.CONST $sra.CODEC_CBUFFER_PREV_READ_ADDR_FIELD      15; //internal state, previous read address of codec cbuffer
.CONST $sra.AUDIO_CBUFFER_PREV_WRITE_ADDR_FIELD     16; //internal state, previous write address of audio cbuffer
.CONST $sra.AUDIO_TOTAL_DECODED_SAMPLES_FIELD       17; //internal state, total number of decoded samples so far
.CONST $sra.SRA_RATE_FIELD                          18; //output: target rate to be used by the sra operator
.CONST $sra.RESET_HIST_FIELD                        19; //internal state, request flag to reset the history
.CONST $sra.HIST_INDEX_FIELD                        20; //internal state, index to history buffer
.CONST $sra.SAVIN_STATE_FIELD                       21; //internal state, leave it initialized to zero
.CONST $sra.BUFFER_LEVEL_COUNTER_FIELD              22; //internal state, counter to calc average buffer level
.CONST $sra.BUFFER_LEVEL_ACC_FIELD                  23; //internal state, accumulator to average buffer level
.CONST $sra.FIX_VALUE_FIELD                         24; //internal state, fix value calculated based on buffer level to fix the final value
.CONST $sra.RATE_BEFORE_FIX_FIELD                   25; //internal state, rate calclated before adding fix value
.CONST $sra.LONG_TERM_RATE_FIELD                    26; //internal state
.CONST $sra.LONG_TERM_RATE_DETECTED_FIELD           27; //internal state
.CONST $sra.AVERAGE_LEVEL_FIELD                     28; //internal state
.CONST $sra.HIST_BUFF_FIELD                         29; //internal state

.CONST $sra.STRUC_SIZE ($sra.HIST_BUFF_FIELD+$sra.BUFF_SIZE);

.CONST $slave_output_rate_op.PORT_OFFSET                    0; // Output port
.CONST $slave_output_rate_op.ACCUMULATOR_DURATION_OFFSET    1; // Accumulator duration (number of timer interrupt periods)
.CONST $slave_output_rate_op.ACCUMULATOR_OFFSET             2; // Accumulated number of samples read from output port
.CONST $slave_output_rate_op.PERIOD_COUNTER_OFFSET          3; // Counter for timing measurement period
.CONST $slave_output_rate_op.PREV_PORT_FILL_LEVEL_OFFSET    4; // Previous output port fill level

.CONST $slave_output_rate_op.STRUC_SIZE                     5;

.CONST $calc_actual_port_rate.RESET                           0;
.CONST $calc_actual_port_rate.WAIT                            1;
.CONST $calc_actual_port_rate.RUN                             2;

// Structure to measure the actual sample rate of a pcm port
.CONST $calc_actual_port_rate.PORT_FIELD                      0; // Output port
.CONST $calc_actual_port_rate.MASTER_RATE_PTR_FIELD           1; // Master rate, if valid will be immediately be used for output rate
.CONST $calc_actual_port_rate.ACCUMULATOR_DURATION_FIELD      2; // Accumulator duration in us (0 -> 1000000 us)
.CONST $calc_actual_port_rate.WAIT_DURATION_FIELD             3; // Wait duration in us (0 -> 100000 us)
.CONST $calc_actual_port_rate.STATE_FIELD                     4; // State
.CONST $calc_actual_port_rate.ACCUMULATOR_FIELD               5; // Accumulated number of samples read from output port
.CONST $calc_actual_port_rate.PREV_PORT_READ_PTR_FIELD        6; // Previous position of output port read pointer (used to calculate actual number of samples output)
.CONST $calc_actual_port_rate.START_TIME_FIELD                7; // time when accumulating started
.CONST $calc_actual_port_rate.SAMPLE_RATE_FIELD               8; // measured sample rate
.CONST $calc_actual_port_rate.SAMPLE_RATE_HIRES_FIELD         9; // measured sample rate x 16
.CONST $calc_actual_port_rate.ACCUMULATOR_REMAINDER_FIELD     10;// saving remainder for accuracy
.CONST $calc_actual_port_rate.STRUC_SIZE                      11;

#define PCM_SYNC_LATENCY_CONVERGE_US                    150 // in us, assumed converged when latency diff reaches to this value
// Structure to synchronise two pcm chains
.CONST $pcm_sync.MAX_RATE_FIELD                         0;  // maximum mismatch rate to compensate
.CONST $pcm_sync.CALC_PERIOD_FIELD                      1;  // rate update period in us
.CONST $pcm_sync.ADJ_CHANNEL_PCM_LATENCY_STRUCT_FIELD   2;  // latency struct for channel to be rate adjusted
.CONST $pcm_sync.REF_CHANNEL_PCM_LATENCY_STRUCT_FIELD   3;  // latency struct for reference channel (can be Null)
.CONST $pcm_sync.ADJ_CHANNEL_SAMPLE_RATE_PTR_FIELD      4;  // sample rate for for channel to be rate adjusted
.CONST $pcm_sync.REF_CHANNEL_SAMPLE_RATE_PTR_FIELD      5;  // sample rate for reference channel
.CONST $pcm_sync.TARGET_LATENCY_US_FIELD                6;  // target diff latency (desired adj_ch_latency-ref_ch_latency)
.CONST $pcm_sync.PREV_TIME_FIELD                        7;  // previous time rate calculated
.CONST $pcm_sync.SRA_RATE_FIELD                         8;  // calculated mismatch rate to be applied to adjust channel
.CONST $pcm_sync.FIX_RATE_FIELD                         9;  // short term fixing rate based on latency
.CONST $pcm_sync.RATE_BEFORE_FIX_FIELD                  10; // long term mismatch rate based on sample rate mismatch
.CONST $pcm_sync.LATENCY_CONVERGED_FIELD                11; // flag showing latency has converged
.CONST $pcm_sync.SAMPLE_RATES_VALID_FIELD               12; // flag showing sample rates are valid
.CONST $pcm_sync.DIFF_LATENCY_FIELD                     13; // latest calculated (diff) latency, output only
.CONST $pcm_sync.STRUC_SIZE                             14;

// Structure to apply HW rate match
.CONST $hw_warp.TIMER_PERIOD_FIELD       0;   // TIMER period
.CONST $hw_warp.TARGET_RATE_PTR_FIELD    1;   // address containg target rate
.CONST $hw_warp.MOVING_STEP_FIELD        2;   // moving step
.CONST $hw_warp.LAST_TIME_FIELD          3;   // last time it warp updated
.CONST $hw_warp.CURRENT_RATE_FIELD       4;   // current hw warp value
.CONST $hw_warp.STRUC_SIZE               5;

#endif
